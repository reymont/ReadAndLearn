SSO单点登录使用token机制来验证用户的安全性 - CTO成长之路——Rosanu - CSDN博客 https://blog.csdn.net/rosanu_blog/article/details/52588570

登录的业务逻辑
{
    http:是短连接.
    
     服务器如何判断当前用户是否登录?
    
    // 1. 如果是即时通信类:长连接.
    // 如何保证服务器跟客户端保持长连接状态?
    

    // "心跳包" 用来检测用户是否在线!用来做长连接!

 

http:短连接使用token 机制来验证用户安全性

    
    // token 值: 登录令牌! 用来判断当前用户的登录状态!
    
    // token 值特点: 是一个字符串/大整数,只需要保证唯一性.是服务器根据用户的信息(账号/密码/身份认证机制(电话号/身份证号/支付宝账号/银行卡信息)...)来生成的用于标识用户身份的值!
    
    // token 值获取:
    

    // 当用户首次登录成功之后, 服务器端就会生成一个 token 值. 

1.会在服务器保存token值(保存在数据库中) 

2.将这个token值返回给客户端.

    

    // 客户端拿到 token 值之后,一般保存在两个位置 : 

1. 将 token 保存在 cookie 中;

2.将 token 保存在沙盒中,作为一个公共参数传递.

    
    // 公共参数: 每一个网络请求都需要的参数! 一般公共参数有很多都是"可选"参数!,公共参数附带的越多,越利于后台监测用户,数据挖掘会使用到监测到的数据.
    
    // 以后客户端再次发送网络请求(一般不是登录请求)的时候,就会将这个 token 值附带到参数中发送给服务器.
    
    // 服务器接收到客户端的请求之后,会取出token值与保存在本地(数据库)中的token值做对比!
    // 如果两个 token 值相同 :说明用户登录成功过!当前用户处于登录状态!
    // 如果没有这个 token 值, 没有登录成功.
    // 如果 token 值不同: 说明原来的登录信息已经失效,让用户重新登录.
    
    
    // token 值失效问题: 1. token 值有失效时间!
    {
        token的有效时间:
        {
            1. 如果 app 是新闻类/游戏类/聊天类等需要长时间用户粘性的. 一般可以设置1年的有效时间!
            
            2. 如果 app 是 支付类/银行类的. 一般token只得有效时间比较短: 15分钟左右!
        }
    }
    
    // token 值失效问题: 2. token 值用来做设备唯一性登录判断!
    {
        每次登录之后,无论用户密码是否改变,只要调用登录接口并且登录成功,都会在服务器生成新的token值,原来的token值就会失效!
        
        典型的 app : 打车软件类
    }


    拓展: 多态设备同时登录. 设备唯一性登录!

{ 

       如果允许多台设备同时登录  ，并且可以设置最大的登录数量的时候。比如说QQ：允许在电脑客户端登录，QQ手机端登录, QQ网页端登录

      如果超出这三个端 想要再另外 一个相同的端登录，需要使对应的端的token失效，来保证一个端 一个账号只登录一次。

      可以设置多个token 根据登录端不同 ，来检测token 是否过期。 根据登录的数量 可以判断最大支持多少个设备同时登录

}

 

}

 

一，OAuth2.0授权协议：

简述：一种安全的登陆协议，用户提交的账户密码不提交到本APP，而是提交到授权服务器，待服务器确认后，返回本APP一个访问令牌，本APP即可用该访问令牌访问资源服务器的资源。由于用户的账号密码并不与本APP直接交互，而是与官方服务器交互，因而它是安全的。

图示：

 

流程：

　　1，获取未授权的Request Token。

　　　　url:request token url。

　　　　param：appKey/appSecret，签名方法/签名（如HMAC-SHA1），timeStamp（时间戳：距1970/0/0/0/0/0的秒数），nonce（随机生成的string，防止重复请求）

　　　　response：Oauth_Token/Oauth_Secret

　　2，获取用户授权的Request Token。

　　　　url:user authorizition url。

　　　　param：Oauth_Token(上个步骤返回的令牌），callback_url（授权成功后返回的地址）

　　　　response：Oauth_Token（被用户授权或否决的令牌）

　　3，用已授权的Request Token换取AccessToken。

　　　　url：access token url。

　　　　param：appKey，Oauth_Token（上个步骤返回的令牌），签名，TimeStamp，nonce

　　　　response：Access_Token/Secret

二，新浪微博的implementation（以ios sdk为例）。

　　1，先封装下列参数：

　　　　　　NSDictionary *params = [NSMutableDictionarydictionaryWithObjectsAndKeys:

                                    self.appKey, @"client_id",

                                    @"code", @"response_type",

                                    self.appRedirectURI, @"redirect_uri",

                                    @"mobile", @"display", nil];

　　　　　　appKey和AppSecret在申请第三方APP的时候即可得到。appRedirectURI只对网页应用有效，所以这里可以随便填一个或者使用默认的。

　　　　　　response_type为code表面其希望返回的是一个授权码（相当于上述的未授权的Request Token）。

　　　　　　display应该是指该请求是移动app的请求。

　　　　然后启动一个WebView，请求url：https://open.weibo.cn/2/oauth2/authorize，带上述参数，方法为get。

　　　　形成的url如：https://open.weibo.cn/2/oauth2/authorize？client_id=1213792051&response_type=code&

　　　　　　　　　　 redirect_uri=https%3A%2F%2Fapi.weibo.com%2Foauth2%2Fdefault.html&display=mobile

　　　　接着就进入了要求输入账号密码的页面

　　　　输入账号密码后,以post方式往https://open.weibo.cn/2/oauth2/authorize发送请求

　　　　出现授权或请求的按钮，至此完成第一部分。

　　　　疑问：协议中的未授权的request token在这里是哪个实体？还是新浪把它弱化掉了，也可能是缓存在webview中。

　　2，点击授权按钮之后，就可以得到Authorization Code了，该授权码相当于以授权的Request Token。

　　3，封装参数

　　　　　　NSDictionary *params = [NSDictionarydictionaryWithObjectsAndKeys:

                            self.appKey, @"client_id",

                            self.appSecret, @"client_secret",

                            @"authorization_code", @"grant_type",

                            self.appRedirectURI, @"redirect_uri",

                            code, @"code", nil];
　　　　　请求url：https://open.weibo.cn/2/oauth2/access_token，方法post，加上述参数，通过NSURLConnection发送请求

　　　　　返回的data就包含access token，当然会判断下该token是否还合法，有效，过期，成功的话会save住下面4个字段。

　　　　　　NSString *access_token = [authInfo objectForKey:@"access_token"];

   　　　　 NSString *uid = [authInfo objectForKey:@"uid"];

    　　　　NSString *remind_in = [authInfo objectForKey:@"remind_in"];

    　　　　NSString *refresh_token = [authInfo objectForKey:@"refresh_token"];

　　　4，以后在请求资源时，就会加上access_token了。

# 3. SSO技术。

　　简述：SSO全场Single Sign On,用户只需登陆一次即可访问相互信任的子系统。用户访问系统1时，登陆成功后会返回一个ticket,当用户访问系统2时，会把ticket带上，待验证合法后即可访问系统2。听起来跟cookie有点像，没错，Web-SSO便有基于cookie的实现方案。很多手机APP在点击新浪授权时，会跳到新浪客户端的登陆页面，这里就用到SSO技术啦。

　　在本APP授权新浪微博时，会先检测手机是否安装了新浪微博客户端。

　　[[UIApplicationsharedApplication] openURL：xxx]可以打开另一个APP。这里sinaweibosso://login为客户端的url并传递三个参数，AppKey，RedirectURI，ssoCallbackScheme。

　　ssoCallbackScheme是返回的App Url地址，即自己定义的sinaweibosso.appKey。

　　登陆成功后，客户端会直接把AccessToken返回给本App。至于在客户端那边发生了哪些交互，暂时不得而知。　　