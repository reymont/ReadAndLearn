Java面试2018常考题目汇总（一） - hope900的博客 - CSDN博客 https://blog.csdn.net/hope900/article/details/78647466/

因为最近在忙着找工作，看到了很多面试整理的文章，于是便有了自己也写一篇，部分原创，大部分是我四处搜集的，我想整理一份最全最新的文章，方便大家总结！废话不多说，开始！
1
一、JAVA基础篇-概念
1.简述你所知道的Linux：

Linux起源于1991年，1995年流行起来的免费操作系统，目前， Linux是主流的服务器操作系统， 广泛应用于互联网、云计算、智能手机（Android）等领域。由于Java主要用于服务器端的开发，因此Java应用的部署环境有很多为Linux。 
Windows操作系统的目录结构，是以盘符为单位，C盘、D盘、E盘等等，数据存储在各个盘符之下，而Linux操作系统最顶层只有一个根目录root，所有文件都存储在这一个根目录之下。 
Linux不像Windows的图形操作界面，是通过命令的方式进行操作，常用命令有： 
a . pwd：用于显示当前工作目录； 
b . ls：用于查看当前工作目录内容； 
c . cd：用于改变当前工作目录。

2.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？

Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。 
Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。

3.JDK、JRE、JVM关系是什么？

JDK（Java Development Kit）即为Java开发工具包，包含编写Java程序所必须的编译、运行等开发工具以及JRE。开发工具如：用于编译java程序的javac命令、用于启动JVM运行java程序的java命令、用于生成文档的javadoc命令以及用于打包的jar命令等等。 
JRE（Java Runtime Environment）即为Java运行环境，提供了运行Java应用程序所必须的软件环境，包含有Java虚拟机（JVM）和丰富的系统类库。系统类库即为java提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。 
JVM（Java Virtual Machines）即为Java虚拟机，提供了字节码文件（.class）的运行环境支持。 
简单说，就是JDK包含JRE包含JVM。

4.Java支持的数据类型有哪些？什么是自动拆装箱？

基本数据类型： 
整数值型：byte,short,int,long, 
字符型：char 
浮点类型：float,double 
布尔型：boolean 
整数默认int型，小数默认是double型。Float和long类型的必须加后缀。

首先知道String是引用类型不是基本类型，引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。引用类型包括类、接口、数组等。String类还是final修饰的。 
而包装类就属于引用类型，自动装箱和拆箱就是基本类型和引用类型之间的转换，至于为什么要转换，因为基本类型转换为引用类型后，就可以new对象，从而调用包装类中封装好的方法进行基本类型之间的转换或者toString（当然用类名直接调用也可以，便于一眼看出该方法是静态的），还有就是如果集合中想存放基本类型，泛型的限定类型只能是对应的包装类型。

5.面向对象是什么？

面向对象是一种思想，世间万物都可以看做一个对象，这里只讨论面向对象编程（OOP），Java是一个支持并发、基于类和面向对象的计算机编程语言，面向对象软件开发的优点：
代码开发模块化，更易维护和修改；
代码复用性强；
增强代码的可靠性和灵活性；
增加代码的可读性。

面向对象的四大基本特性：
抽象：提取现实世界中某事物的关键特性，为该事物构建模型的过程。对同一事物在不同的需求下，需要提取的特性可能不一样。得到的抽象模型中一般包含：属性（数据）和操作（行为）。这个抽象模型我们称之为类。对类进行实例化得到对象。

封装：封装可以使类具有独立性和隔离性；保证类的高内聚。只暴露给类外部或者子类必须的属性和操作。类封装的实现依赖类的修饰符（public、protected和private等）

继承：对现有类的一种复用机制。一个类如果继承现有的类，则这个类将拥有被继承类的所有非私有特性（属性和操作）。这里指的继承包含：类的继承和接口的实现。

多态：多态是在继承的基础上实现的。多态的三个要素：继承、重写和父类引用指向子类对象。父类引用指向不同的子类对象时，调用相同的方法，呈现出不同的行为；就是类多态特性。多态可以分成编译时多态和运行时多态。

抽象、封装、继承和多态是面向对象的基础。在面向对象四大基础特性之上，我们在做面向对象编程设计时还需要遵循有一些基本的设计原则。

面向对象的七大设计原则：
SOLID原则（单一职责原则、开放关闭原则、里氏替换原则、接口隔离原则和依赖倒置原则） 
迪米特法则 
组合优于继承原则（合成复用原则）。 
在遵循这些面向对象设计原则基础上，前辈们总结出一些解决不同问题场景的设计模式，以四人帮的gof23最为知名。

24种设计模式(gof23+1)：
创建型模式： 
1.简单工厂模式（不包含在gof23中） 
2.工厂模式 
3.抽象工厂模式 
4.单例模式 
5.原型模式 
创建者模式 
6.结构型模式： 
7.组合模式 
8.装饰者模式 
9.外观模式 
10.适配器模式 
11.代理模式 
12.享元模式 
13.桥接模式 
行为型模式： 
14.观察者模式 
15.策略模式 
16.状态模式 
17.中介模式 
18.模板方法 
19.命令模式 
20.备忘录模式 
21.访问者模式 
22.解释器模式 
23.迭代器模式 
24.职责链模式 
这里只是简单描述了定义和特征以及设计模式的关系，具体细节不讨论。

## 6.请写出下面几个表达式的结果，答案可以用10进制或16进制书写

1). 0xaa | 0x55 
2). 15 & 240 
3). 10 ^ 12 
4). -2 >> 1 
5). -2 >>> 1 
1). 分析：十六进制数用0x……来表示，后面一个十六进制位是四位，两个十六进制位为一个字节，最多后面可以有8个十六进制位，32个字节,如：0xFFFFFFFF。 或（“ | ”）运算，全0为0，其他为1。
十六进制转换有16进制每一位上可以是从小到大为0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F16个大小不同的数，即逢16进1，其中用A，B，C，D，E，F（字母不区分大小写）这六个字母来分别表示10，11，12，13，14，15。
`A代表11` 0xA=10=1000+10
所以：0xaa 用二进制表示为 10101010 ,0x55 用二进制表示为 01010101 ,按位或之后为 11111111 ，十进制数为255，十六进制数为 0xFF 。

2). 分析：10进制转换成2进制，用该数字除以2，记录商和余数，利用商再次除以2，记录商和余数……直到上为0或余数为0停止，余数逆序组成二进制的从低到高位（最后的余数为二进制最低位）。与（“ & ”）运算，全1为1，其他为0 。 
15/2=8余1
8/2=4
4/2=2
2/2=1
所以： 15 等于1111 ，240等于 11110000，15前面用0补齐为00001111 ，按位与之后为 00000000 ，即结果为0

3). 分析： 亦或（“ ^ ”）运算，相同取0，不同取1 。 
所以：1010 ^ 1100 =0110 , 十进制表示为6，十六进制表示为 0x06 。

4). 分析： 带符号右移（“ >> ”），即有符号位时，负数符号位补1，正数符号位补0， -2 的二进制求法是正数取反加1，因此 2 的二进制表示为0000 0000 0000 0000 0000 0000 0000 0010 ，取反加一为 
1111 1111 1111 1111 1111 1111 1111 1110 ，即 -2 的二进制表示。 
注： >> , << , >>> , 运算符只针对int型和long型，byte ,short ,char型需要转换成Int型在进行操作。 
所以： 带符号右移之后为 1111 1111 1111 1111 1111 1111 1111 1111 ，除符号位之外，减一取反，得到带符号十进 制数为 -1 。

5). 分析：无符号右移 (“ >>> ”) ，即无论正负数，右移之后符号位均补 0 。 
所以： -2 的二进制无符号右移一位之后为 0111 1111 1111 1111 1111 1111 1111 1111，即 2^31 - 1,二的三十一次方减一。 
注：右移和无符号右移主要区别就在于左面最高位补 0 还是补 1 的问题，无符号右移任何时候最高位都补 0 ， 有符号右移则是正数补 0 ，负数补 1 。（没有无符号左移！）。

7.&和&&的区别？

&运算符有两种用法：(1)按位与；(2)逻辑与。&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算是因为，如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &&!username.equals(“”)，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。

8.什么是值传递和引用传递？

值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. 
引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 
一般认为,java内的传递都是值传递. java中实例对象的传递是引用传递 。

9.是否可以在static环境中访问非static变量？

static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。

10.Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？

Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。

11.Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？

当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。 
Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。 
Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。

12.Java支持多继承么？

Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。

13.解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。

通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。

14.接口和抽象类的区别是什么？

从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 
Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于： 
接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。 
类可以实现很多个接口，但是只能继承一个抽象类 
类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 
抽象类可以在不提供接口方法实现的情况下实现接口。 
Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。 
Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。 
接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。 
也可以参考JDK8中抽象类和接口的区别。

15.用最有效率的方法计算2乘以8？

答： 2 << 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。

16.手写单例模式（饿汉和饱汉模式）和工厂模式？

(1)单例饿汉模式://饿汉式单例类.在类初始化时，已经自行实例化 
2 public class Singleton1 { 
3 //私有的默认构造子 
4 private Singleton1() {} 
5 //已经自行实例化 
6 private static final Singleton1 single = new Singleton1(); 
7 //静态工厂方法 
8 public static Singleton1 getInstance() { 
9 return single; 
10 } 
11 }

(2)懒汉模式://懒汉式单例类.在第一次调用的时候实例化 
2 public class Singleton2 { 
3 //私有的默认构造子 
4 private Singleton2() {} 
5 //注意，这里没有final 
6 private static Singleton2 single=null; 
7 //静态工厂方法 
8 public synchronized static Singleton2 getInstance() { 
9 if (single == null) { 
10 single = new Singleton2(); 
11 } 
12 return single; 
13 } 
14 }

(3)工厂模式: 
interface IFactory{ 
public IProduct createProduct();} 
Class Factory implements IFactory{ 
public IProduct createProduct(){return new Product();}} 
Public class client{ 
Public Static void main (String [] args){IFactory factory=new Factory(); 
IProduct product=factory.createProduct(); 
product.ProductMethod();}}

17.String和StringBuilder、StringBuffer的区别？

Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。

二、JAVA基础篇-集合与数组
18.Java集合框架是什么？说出一些集合框架的优点？

每种编程语言中都有集合，最初的Java版本包含几种集合类：Vector、Stack、HashTable和Array。随着集合的广泛使用，Java1.2提出了囊括所有集合接口、实现和算法的集合框架。在保证线程安全的情况下使用泛型和并发集合类，Java已经经历了很久。它还包括在Java并发包中，阻塞接口以及它们的实现。集合框架的部分优点如下： 
（1）使用核心集合类降低开发成本，而非实现我们自己的集合类。 
（2）随着使用经过严格测试的集合框架类，代码质量会得到提高。 
（3）通过使用JDK附带的集合类，可以降低代码维护成本。 
（4）复用性和可操作性。

19.集合框架中的泛型有什么优点？

Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。泛型也使得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。

20.Java集合框架的基础接口有哪些？

Collection为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java平台不提供这个接口任何直接的实现。## 标题 ## 
Set是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。 
List是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List更像长度动态变换的数组。 
Map是一个将key映射到value的对象.一个Map不能包含重复的key：每个key最多只能映射一个value。 
一些其它的接口有Queue、Dequeue、SortedSet、SortedMap和ListIterator。

21.为何Collection不从Cloneable和Serializable接口继承？

Collection接口指定一组对象，对象即为它的元素。如何维护这些元素由Collection的具体实现决定。例如，一些如List的Collection实现允许重复的元素，而其它的如Set就不允许。很多Collection实现有一个公有的clone方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为Collection是一个抽象表现。重要的是实现。 
当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。 
在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制。特定的实现应该决定它是否可以被克隆和序列化。

22.为何Map接口不继承Collection接口？

尽管Map接口和它的实现也是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map继承Collection毫无意义，反之亦然。 
如果Map继承Collection接口，那么元素去哪儿？Map包含key-value对，它提供抽取key或value列表集合的方法，但是它不适合“一组对象”规范。

23.什么是迭代器(Iterator)？

Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。

24.Iterator和ListIterator的区别是什么？

下面列出了他们的区别： 
Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 
Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 
ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

25.快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？

快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个ConcurrentModification异常。 
在java.util包下的都是快速失败。 
安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出ConcurrentModification异常。 
在java.util.concurrent包下的全是安全失败的。

26.Java中的HashMap的工作原理是什么？

我们知道在Java中最常用的两种结构是数组和模拟指针(引用)，几乎所有的数据结构都可以利用这两种来组合实现，HashMap也是如此。实际上HashMap是一个“链表散列”，如下是它数据结构：最左侧是一个数组，数组中的每一个元素都是一个链表，链表的每一个元素都是entry。

HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。

27.当两个对象的hashcode相同会发生什么？

因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。

28.如果两个键的hashcode相同，你如何获取值对象？

当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。

29.hashCode()和equals()方法有何重要性？

HashMap使用Key对象的hashCode()和equals()方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则： 
（1）如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。 
（2）如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。 
具体可以参考 http://blog.csdn.net/javazejian/article/details/51348320

30.HashMap和Hashtable有什么区别？

1、HashMap是非线程安全的，HashTable是线程安全的。 
2、HashMap的键和值都允许有null值存在，而HashTable则不行。 
3、因为线程安全的问题，HashMap效率比HashTable的要高。 
4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。 
一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。

31.如何决定选用HashMap还是TreeMap？

对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。

32.ArrayList和Vector有何异同点？

ArrayList和Vector在很多时候都很类似。 
（1）两者都是基于索引的，内部由一个数组支持。 
（2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。 
（3）ArrayList和Vector的迭代器实现都是fail-fast的。 
（4）ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。 
以下是ArrayList和Vector的不同点。 
（1）Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。 
（2）ArrayList比Vector快，它因为有同步，不会过载。 
（3）ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。

33.Array和ArrayList有何区别？什么时候更适合用Array？

Array可以容纳基本类型和对象，而ArrayList只能容纳对象。 
Array是指定大小的，而ArrayList大小是固定的。 
Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。尽管ArrayList明显是更好的选择，但也有些时候Array比较好用。 
（1）如果列表的大小已经指定，大部分情况下是存储和遍历它们。 
（2）对于遍历基本数据类型，尽管Collections使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。 
（3）如果你要使用多维数组，使用[][]比List
--------------------- 
作者：hopeplus 
来源：CSDN 
原文：https://blog.csdn.net/hope900/article/details/78647466 
版权声明：本文为博主原创文章，转载请附上博文链接！