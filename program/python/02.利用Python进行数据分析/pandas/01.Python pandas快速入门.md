
## 参考
1. Python pandas快速入门 - CSDN博客 https://blog.csdn.net/qq_16234613/article/details/62046057
2. pd库dataframe基本操作 - 我不是小鲁班 - 博客园 http://www.cnblogs.com/luban/p/9117360.html
3. 用python做数据分析4|pandas库介绍之DataFrame基本操作 - 简书 https://www.jianshu.com/p/682c24aef525

# 一、查看数据（查看对象的方法对于Series来说同样适用）
## 1.1. 查看DataFrame前xx行或后xx行
a=DataFrame(data);
a.head(6)表示显示前6行数据，若head()中不带参数则会显示全部数据。
a.tail(6)表示显示后6行数据，若tail()中不带参数则也会显示全部数据。

## 1.2. 查看DataFrame的index，columns以及values
a.index ; a.columns ; a.values 即可
a.values[0]

## 1.3. describe()函数对于数据的快速统计汇总
a.describe()对每一列数据进行统计，包括计数，均值，std，各个分位数等。

## 1.4. 对数据的转置
a.T

## 5.对轴进行排序
a.sort_index(axis=1,ascending=False)；
其中axis=1表示对所有的columns进行排序，下面的数也跟着发生移动。后面的ascending=False表示按降序排列，参数缺失时默认升序。

## 6.对DataFrame中的值排序
a.sort(columns='x')
即对a中的x这一列，从小到大进行排序。注意仅仅是x这一列，而上面的按轴进行排序时会对所有的columns进行操作。

# 二、选择对象
1.选择特定列和行的数据
a['x'] 那么将会返回columns为x的列，注意这种方式一次只能返回一个列。a.x与a['x']意思一样。

取行数据，通过切片[]来选择
如：a[0:3] 则会返回前三行的数据。

2.loc是通过标签来选择数据
a.loc['one']则会默认表示选取行为'one'的行；

a.loc[:,['a','b'] ] 表示选取所有的行以及columns为a,b的列；

a.loc[['one','two'],['a','b']] 表示选取'one'和'two'这两行以及columns为a,b的列；

a.loc['one','a']与a.loc[['one'],['a']]作用是一样的，不过前者只显示对应的值，而后者会显示对应的行和列标签。

3.iloc则是直接通过位置来选择数据
这与通过标签选择类似
a.iloc[1:2,1:2] 则会显示第一行第一列的数据;(切片后面的值取不到)

a.iloc[1:2] 即后面表示列的值没有时，默认选取行位置为1的数据;

a.iloc[[0,2],[1,2]] 即可以自由选取行位置，和列位置对应的数据。

4.使用条件来选择
使用单独的列来选择数据
a[a.c>0] 表示选择c列中大于0的数据

使用where来选择数据
a[a>0] 表直接选择a中所有大于0的数据

使用isin()选出特定列中包含特定值的行
a1=a.copy()
a1[a1['one'].isin(['2','3'])] 表显示满足条件：列one中的值包含'2','3'的所有行。

# 三、设置值（赋值）
赋值操作在上述选择操作的基础上直接赋值即可。
例a.loc[:,['a','c']]=9 即将a和c列的所有行中的值设置为9
a.iloc[:,[1,3]]=9 也表示将a和c列的所有行中的值设置为9

同时也依然可以用条件来直接赋值
a[a>0]=-a 表示将a中所有大于0的数转化为负值

# 四、缺失值处理
在pandas中，使用np.nan来代替缺失值，这些值将默认不会包含在计算中。

1.reindex()方法
用来对指定轴上的索引进行改变/增加/删除操作，这将返回原始数据的一个拷贝。
a.reindex(index=list(a.index)+['five'],columns=list(a.columns)+['d'])

a.reindex(index=['one','five'],columns=list(a.columns)+['d'])

即用index=[]表示对index进行操作，columns表对列进行操作。

** 2.对缺失值进行填充**
a.fillna(value=x)
表示用值为x的数来对缺失值进行填充

** 3.去掉包含缺失值的行**
a.dropna(how='any')
表示去掉所有包含缺失值的行

4.空数据行列的处理：

可以通过axis参数来删除含有空数据的全部列
```py
df4 = df4.dropna(axis=1)

# 可以通过subset参数来删除在age和sex中含有空数据的全部行
df4 = df4.dropna(subset=["age", "sex"])
print(df4)
df4 = df4.dropna(subset=['age', 'body','home.dest'])
```
# 五、合并
1.contact
contact(a1,axis=0/1，keys=['xx','xx','xx',...])，其中a1表示要进行进行连接的列表数据,axis=1时表横着对数据进行连接。axis=0或不指定时，表将数据竖着进行连接。a1中要连接的数据有几个则对应几个keys，设置keys是为了在数据连接以后区分每一个原始a1中的数据。

例：a1=[b['a'],b['c']]
result=pd.concat(a1,axis=1，keys=['1','2'])

2.Append 将一行或多行数据连接到一个DataFrame上
a.append(a[2:],ignore_index=True)
表示将a中的第三行以后的数据全部添加到a中，若不指定ignore_index参数，则会把添加的数据的index保留下来，若ignore_index=Ture则会对所有的行重新自动建立索引。

3.merge类似于SQL中的join
设a1,a2为两个dataframe,二者中存在相同的键值，两个对象连接的方式有下面几种：
(1)内连接，pd.merge(a1, a2, on='key')
(2)左连接，pd.merge(a1, a2, on='key', how='left')
(3)右连接，pd.merge(a1, a2, on='key', how='right')
(4)外连接， pd.merge(a1, a2, on='key', how='outer')
至于四者的具体差别，具体学习参考sql中相应的语法。

删除重复行

 

第一个想法：把所有重复的行去掉

第二个想法：只保留第一次出现的重复行

第三个想法：保留最后一次出现的重复行

这三个想法都可以用pandas中自带一个方法实现。 DataFrame.drop_duplicates()

newdata.drop_duplicates(subset=['A','B','C','D'],keep=False)
上面这一句代码就是把所有重复的行去掉，subset这个参数后面我会提到，keep这个参数就是选择我们前面三个想法中的哪一个？

当keep=False时，就是去掉所有的重复行

当keep=‘first'时，就是保留第一次出现的重复行

当keep='last'时就是保留最后一次出现的重复行。（注意，这里的参数是字符串）

下面讲一下subset这个参数。
在上面的场景中，我们对重复的定义是：在某一行，若A、B、C、D这四列如果都相同的话就是重复。
但是有时候，我们重复并不需要所有列都相同，我们只需要其中的某几列相同就可以当作重复。因此subset这个参数就是来设置这个的。
举个栗子，还是上面这个数据集，如果我们想把A列和B列中元素相同的行去掉，只保留第一次出现的行，要怎么做？

很简单，

newdata.drop_duplicates(subset=['A','B'],keep='first')
 



从结果上我们可以看到，第0行和第1行由于A列B列相同，而且选择保留第一次出现的行，所以第1行被去掉。
第2行和第5行的A列B列相同，保留第一次出现的行，所以第5行被去掉。

# 六、分组（groupby）
用pd.date_range函数生成连续指定天数的的日期
pd.date_range('20000101',periods=10)

def shuju():
    data={
        'date':pd.date_range('20000101',periods=10),
        'gender':np.random.randint(0,2,size=10),
        'height':np.random.randint(40,50,size=10),
        'weight':np.random.randint(150,180,size=10)
    }
a=DataFrame(data)
print(a)
        date  gender  height  weight
0 2000-01-01       0      47     165
1 2000-01-02       0      46     179
2 2000-01-03       1      48     172
3 2000-01-04       0      45     173
4 2000-01-05       1      47     151
5 2000-01-06       0      45     172
6 2000-01-07       0      48     167
7 2000-01-08       0      45     157
8 2000-01-09       1      42     157
9 2000-01-10       1      42     164

用a.groupby('gender').sum()得到的结果为：  #注意在python中groupby(''xx)后要加sum()，不然显示
不了数据对象。
gender     height  weight               
0           256     989
1           170     643
此外用a.groupby('gender').size()可以对各个gender下的数目进行计数。

所以可以看到groupby的作用相当于：
按gender对gender进行分类，对应为数字的列会自动求和，而为字符串类型的列则不显示；当然也可以同时groupby(['x1','x2',...])多个字段，其作用与上面类似。

# 七、Categorical按某一列重新编码分类
如六中要对a中的gender进行重新编码分类，将对应的0，1转化为male，female，过程如下：

a['gender1']=a['gender'].astype('category')
a['gender1'].cat.categories=['male','female']  #即将0，1先转化为category类型再进行编码。

 print(a)得到的结果为：
      date    gender  height  weight gender1
0 2000-01-01       1      40     163  female
1 2000-01-02       0      44     177    male
2 2000-01-03       1      40     167  female
3 2000-01-04       0      41     161    male
4 2000-01-05       0      48     177    male
5 2000-01-06       1      46     179  female
6 2000-01-07       1      42     154  female
7 2000-01-08       1      43     170  female
8 2000-01-09       0      46     158    male
9 2000-01-10       1      44     168  female
所以可以看出重新编码后的编码会自动增加到dataframe最后作为一列。

# 八、相关操作
描述性统计：
1.a.mean() 默认对每一列的数据求平均值；若加上参数a.mean(1)则对每一行求平均值；

2.统计某一列x中各个值出现的次数：a['x'].value_counts()；

3.对数据应用函数
a.apply(lambda x:x.max()-x.min())
表示返回所有列中最大值-最小值的差。

4.字符串相关操作
a['gender1'].str.lower() 将gender1中所有的英文大写转化为小写，注意dataframe没有str属性，只有series有，所以要选取a中的gender1字段。

九、时间序列
在六中用pd.date_range('xxxx',periods=xx,freq='D/M/Y....')函数生成连续指定天数的的日期列表。
例如pd.date_range('20000101',periods=10),其中periods表示持续频数；
pd.date_range('20000201','20000210',freq='D')也可以不指定频数，只指定起始日期。

此外如果不指定freq，则默认从起始日期开始，频率为day。其他频率表示如下：


 

1.png
十、画图(plot)
在pycharm中首先要：import matplotlib.pyplot as plt
a=Series(np.random.randn(1000),index=pd.date_range('20100101',periods=1000))
b=a.cumsum()
b.plot()
plt.show()    #最后一定要加这个plt.show()，不然不会显示出图来。
 

2.PNG

也可以使用下面的代码来生成多条时间序列图：

a=DataFrame(np.random.randn(1000，4),index=pd.date_range('20100101',periods=1000),columns=list('ABCD'))
b=a.cumsum()
b.plot()
plt.show() 
 

3.png

# 十一、导入和导出文件
写入和读取excel文件
虽然写入excel表时有两种写入xls和csv，但建议少使用csv，不然在表中调整数据格式时，保存时一直询问你是否保存新格式，很麻烦。而在读取数据时，如果指定了哪一张sheet，则在pycharm又会出现格式不对齐。

还有将数据写入表格中时，excel会自动给你在表格最前面增加一个字段，对数据行进行编号。

a.to_excel(r'C:\\Users\\guohuaiqi\\Desktop\\2.xls',sheet_name='Sheet1')    

a=pd.read_excel(r'C:\\Users\\guohuaiqi\\Desktop\\2.xls','Sheet1',na_values=['NA'])

注意sheet_name后面的Sheet1中的首字母大写；读取数据时，可以指定读取哪一张表中的数据，而
且对缺失值补上NA。

最后再附上写入和读取csv格式的代码：
a.to_csv(r'C:\\Users\\guohuaiqi\\Desktop\\1.csv'，sheet_name='Sheet1')
a=pd.read_csv(r'C:\\Users\\guohuaiqi\\Desktop\\1.csv',na_values=['NA'])

参考地址：https://www.jianshu.com/p/682c24aef525



Dimensions	Name	Description
1	Series	1D labeled homogeneously-typed array
2	DataFrame	General 2D labeled, size-mutable tabular structure with potentially heterogeneously-typed columns
3	Panel	General 3D labeled, also size-mutable array
一、引入
import pandas as pd   //数据分析，代码基于numpy
import numpy as np    //处理数据，代码基于ndarray
import matplotlib.pyplot as plt      //画图
matplotlib图库具有大量代码案例，可直接使用 
pandas 官网教程

二、创建对象
Series字典对象

>>>s = pd.Series([1,3,5,np.nan,6,8])   //默认以数字从0开始作为键值,使用np.nan表示不参与计算
>>>s
0    1.0
1    3.0
2    5.0
3    NaN
4    6.0
5    8.0
dtype: float64
1
2
3
4
5
6
7
8
9
>>> s = pd.Series(data=[1,2,3,4],index = ['a','b','c','d'])  //传入键和值方式
>>> s
a    1
b    2
c    3
d    4
dtype: int64
>>> s.index    //获取键列表
Index(['a', 'b', 'c', 'd'], dtype='object')
>>> s.values    //获取值列表
array([1, 2, 3, 4], dtype=int64)
1
2
3
4
5
6
7
8
9
10
11
DataFrame表格对象

In [10]: df2 = pd.DataFrame({ 'A' : 1.,
                     'B' : pd.Timestamp('20130102'),
                     'C' : pd.Series(1,index=list(range(4)),dtype='float32'),   //生成Series对象,取的是value
                     'D' : np.array([3] * 4,dtype='int32'),  //生成numpy对象
                     'E' : pd.Categorical(["test","train","test","train"]),
                     'F' : 'foo' })  


In [11]: df2
Out[11]:          // 默认以数字从0开始作为行键,以字典键为列键
     A          B    C  D      E    F
0  1.0 2013-01-02  1.0  3   test  foo
1  1.0 2013-01-02  1.0  3  train  foo
2  1.0 2013-01-02  1.0  3   test  foo
3  1.0 2013-01-02  1.0  3  train  foo
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
In [6]: dates = pd.date_range('20130101', periods=6)

In [7]: dates
Out[7]: 
DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
               '2013-01-05', '2013-01-06'],
              dtype='datetime64[ns]', freq='D')

In [8]: df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list('ABCD'))    //np.random.randn(6,4)返回一个样本，具有标准正态分布

In [9]: df
Out[9]:          // 指定dates为行键，columns为列键
                   A         B         C         D
2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
2013-01-02  1.212112 -0.173215  0.119209 -1.044236
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
2013-01-04  0.721555 -0.706771 -1.039575  0.271860
2013-01-05 -0.424972  0.567020  0.276232 -1.087401
2013-01-06 -0.673690  0.113648 -1.478427  0.524988


In [12]: df2.dtypes    //查看列数据类型
Out[12]: 
A           float64
B    datetime64[ns]
C           float32
D             int32
E          category
F            object
dtype: object
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
三、查看数据
查看头尾数据：

In [14]: df.head()    //默认值5
Out[14]: 
                   A         B         C         D
2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
2013-01-02  1.212112 -0.173215  0.119209 -1.044236
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
2013-01-04  0.721555 -0.706771 -1.039575  0.271860
2013-01-05 -0.424972  0.567020  0.276232 -1.087401

In [15]: df.tail(3)     //默认值5
Out[15]:  
                   A         B         C         D
2013-01-04  0.721555 -0.706771 -1.039575  0.271860
2013-01-05 -0.424972  0.567020  0.276232 -1.087401
2013-01-06 -0.673690  0.113648 -1.478427  0.524988
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
查看行键、列键、数据：

In [16]: df.index
Out[16]: 
DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
               '2013-01-05', '2013-01-06'],
              dtype='datetime64[ns]', freq='D')

In [17]: df.columns
Out[17]: Index([u'A', u'B', u'C', u'D'], dtype='object')

In [18]: df.values
Out[18]: 
array([[ 0.4691, -0.2829, -1.5091, -1.1356],
       [ 1.2121, -0.1732,  0.1192, -1.0442],
       [-0.8618, -2.1046, -0.4949,  1.0718],
       [ 0.7216, -0.7068, -1.0396,  0.2719],
       [-0.425 ,  0.567 ,  0.2762, -1.0874],
       [-0.6737,  0.1136, -1.4784,  0.525 ]])
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
查看数据整体概况，和、平均值、最大、最小等：

In [19]: df.describe()
Out[19]: 
              A         B         C         D
count  6.000000  6.000000  6.000000  6.000000
mean   0.073711 -0.431125 -0.687758 -0.233103
std    0.843157  0.922818  0.779887  0.973118
min   -0.861849 -2.104569 -1.509059 -1.135632
25%   -0.611510 -0.600794 -1.368714 -1.076610
50%    0.022070 -0.228039 -0.767252 -0.386188
75%    0.658444  0.041933 -0.034326  0.461706
max    1.212112  0.567020  0.276232  1.071804
1
2
3
4
5
6
7
8
9
10
11
train_df.info()
print('_'*40)
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 891 entries, 0 to 890
Data columns (total 12 columns):
PassengerId    891 non-null int64
Survived       891 non-null int64
Pclass         891 non-null int64
Name           891 non-null object
Sex            891 non-null object
Age            714 non-null float64
SibSp          891 non-null int64
Parch          891 non-null int64
Ticket         891 non-null object
Fare           891 non-null float64
Cabin          204 non-null object
Embarked       889 non-null object
dtypes: float64(2), int64(5), object(5)
memory usage: 83.6+ KB
________________________________________
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
train_df.describe(include=['O'])

Name    Sex Ticket  Cabin   Embarked
count   891 891 891 204 889
unique  891 2   681 147 3
top Chronopoulos, Mr. Apostolos male    CA. 2343    G6  S
freq    1   577 7   4   644
1
2
3
4
5
6
7
行或列平均值：

In [61]: df.mean()
Out[61]: 
A   -0.004474
B   -0.383981
C   -0.687758
D    5.000000
F    3.000000
dtype: float64
1
2
3
4
5
6
7
8
In [62]: df.mean(1)
Out[62]: 
2013-01-01    0.872735
2013-01-02    1.431621
2013-01-03    0.707731
2013-01-04    1.395042
2013-01-05    1.883656
2013-01-06    1.592306
Freq: D, dtype: float64
1
2
3
4
5
6
7
8
9
转置：

In [20]: df.T
Out[20]: 
   2013-01-01  2013-01-02  2013-01-03  2013-01-04  2013-01-05  2013-01-06
A    0.469112    1.212112   -0.861849    0.721555   -0.424972   -0.673690
B   -0.282863   -0.173215   -2.104569   -0.706771    0.567020    0.113648
C   -1.509059    0.119209   -0.494929   -1.039575    0.276232   -1.478427
D   -1.135632   -1.044236    1.071804    0.271860   -1.087401    0.524988
1
2
3
4
5
6
7
根据行、列排序：

In [21]: df.sort_index(axis=1, ascending=False)    //根据轴，可以.sort_index(axis=0, by=None, ascending=True)。by参数只能对列
Out[21]: 
                   D         C         B         A
2013-01-01 -1.135632 -1.509059 -0.282863  0.469112
2013-01-02 -1.044236  0.119209 -0.173215  1.212112
2013-01-03  1.071804 -0.494929 -2.104569 -0.861849
2013-01-04  0.271860 -1.039575 -0.706771  0.721555
2013-01-05 -1.087401  0.276232  0.567020 -0.424972
2013-01-06  0.524988 -1.478427  0.113648 -0.673690
Sorting by values

In [22]: df.sort_values(by='B')       //根据值
Out[22]: 
                   A         B         C         D
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
2013-01-04  0.721555 -0.706771 -1.039575  0.271860
2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
2013-01-02  1.212112 -0.173215  0.119209 -1.044236
2013-01-06 -0.673690  0.113648 -1.478427  0.524988
2013-01-05 -0.424972  0.567020  0.276232 -1.087401
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
四、选择数据
选择单列：

In [23]: df['A']  //可使用df.A
Out[23]: 
2013-01-01    0.469112
2013-01-02    1.212112
2013-01-03   -0.861849
2013-01-04    0.721555
2013-01-05   -0.424972
2013-01-06   -0.673690
Freq: D, Name: A, dtype: float64
1
2
3
4
5
6
7
8
9
选择局部：

In [24]: df[0:3]
Out[24]: 
                   A         B         C         D
2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
2013-01-02  1.212112 -0.173215  0.119209 -1.044236
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804

In [25]: df['20130102':'20130104']
Out[25]: 
                   A         B         C         D
2013-01-02  1.212112 -0.173215  0.119209 -1.044236
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
2013-01-04  0.721555 -0.706771 -1.039575  0.271860
1
2
3
4
5
6
7
8
9
10
11
12
13
标签选择： 
通过行键，列键

In [26]: df.loc[dates[0]]        //选择一行，会降维
Out[26]: 
A    0.469112
B   -0.282863
C   -1.509059
D   -1.135632
Name: 2013-01-01 00:00:00, dtype: float64
1
2
3
4
5
6
7
In [27]: df.loc[:,['A','B']]  //局部选择
Out[27]: 
                   A         B
2013-01-01  0.469112 -0.282863
2013-01-02  1.212112 -0.173215
2013-01-03 -0.861849 -2.104569
2013-01-04  0.721555 -0.706771
2013-01-05 -0.424972  0.567020
2013-01-06 -0.673690  0.113648
1
2
3
4
5
6
7
8
9
In [28]: df.loc['20130102':'20130104',['A','B']]    //局部选择
Out[28]: 
                   A         B
2013-01-02  1.212112 -0.173215
2013-01-03 -0.861849 -2.104569
2013-01-04  0.721555 -0.706771
1
2
3
4
5
6
In [29]: df.loc['20130102',['A','B']]   //选择一行，会降维
Out[29]: 
A    1.212112
B   -0.173215
Name: 2013-01-02 00:00:00, dtype: float64
1
2
3
4
5
In [30]: df.loc[dates[0],'A']   //选择具体某个元素，会降维
Out[30]: 0.46911229990718628
1
2
In [31]: df.at[dates[0],'A']     //选择具体某个元素，会降维
Out[31]: 0.46911229990718628
1
2
位置选择： 
存在一个从0开始类似于数组

In [32]: df.iloc[3]
Out[32]: 
A    0.721555
B   -0.706771
C   -1.039575
D    0.271860
Name: 2013-01-04 00:00:00, dtype: float64
1
2
3
4
5
6
7
In [33]: df.iloc[3:5,0:2]
Out[33]: 
                   A         B
2013-01-04  0.721555 -0.706771
2013-01-05 -0.424972  0.567020
1
2
3
4
5
In [34]: df.iloc[[1,2,4],[0,2]]
Out[34]: 
                   A         C
2013-01-02  1.212112  0.119209
2013-01-03 -0.861849 -0.494929
2013-01-05 -0.424972  0.276232
1
2
3
4
5
6
In [35]: df.iloc[1:3,:]
Out[35]: 
                   A         B         C         D
2013-01-02  1.212112 -0.173215  0.119209 -1.044236
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
1
2
3
4
5
In [36]: df.iloc[:,1:3]
Out[36]: 
                   B         C
2013-01-01 -0.282863 -1.509059
2013-01-02 -0.173215  0.119209
2013-01-03 -2.104569 -0.494929
2013-01-04 -0.706771 -1.039575
2013-01-05  0.567020  0.276232
2013-01-06  0.113648 -1.478427
1
2
3
4
5
6
7
8
9
In [37]: df.iloc[1,1]
Out[37]: -0.17321464905330858
1
2
In [38]: df.iat[1,1]
Out[38]: -0.17321464905330858
1
2
布尔索引：

In [39]: df[df.A > 0]
Out[39]: 
                   A         B         C         D
2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
2013-01-02  1.212112 -0.173215  0.119209 -1.044236
2013-01-04  0.721555 -0.706771 -1.039575  0.271860
1
2
3
4
5
6
In [40]: df[df > 0]
Out[40]: 
                   A         B         C         D
2013-01-01  0.469112       NaN       NaN       NaN
2013-01-02  1.212112       NaN  0.119209       NaN
2013-01-03       NaN       NaN       NaN  1.071804
2013-01-04  0.721555       NaN       NaN  0.271860
2013-01-05       NaN  0.567020  0.276232       NaN
2013-01-06       NaN  0.113648       NaN  0.524988
1
2
3
4
5
6
7
8
9
In [41]: df2 = df.copy()

In [42]: df2['E'] = ['one', 'one','two','three','four','three']

In [43]: df2
Out[43]: 
                   A         B         C         D      E
2013-01-01  0.469112 -0.282863 -1.509059 -1.135632    one
2013-01-02  1.212112 -0.173215  0.119209 -1.044236    one
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804    two
2013-01-04  0.721555 -0.706771 -1.039575  0.271860  three
2013-01-05 -0.424972  0.567020  0.276232 -1.087401   four
2013-01-06 -0.673690  0.113648 -1.478427  0.524988  three

In [44]: df2[df2['E'].isin(['two','four'])]
Out[44]: 
                   A         B         C         D     E
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804   two
2013-01-05 -0.424972  0.567020  0.276232 -1.087401  four
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
五、修改数据
读取时将多列并成一列：

def parse(x):
    return datetime.strptime(x, '%Y %m %d %H')
dataset = read_csv('raw.csv',  parse_dates = [['year', 'month', 'day', 'hour']], index_col=0, date_parser=parse)
1
2
3
Series赋值列：

In [45]: s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range('20130102', periods=6))

In [46]: s1
Out[46]: 
2013-01-02    1
2013-01-03    2
2013-01-04    3
2013-01-05    4
2013-01-06    5
2013-01-07    6
Freq: D, dtype: int64

In [47]: df['F'] = s1     //通过Series赋值列
1
2
3
4
5
6
7
8
9
10
11
12
13
赋值单个元素：

df.at[dates[0],'A'] = 0
df.iat[0,1] = 0
1
2
3
df.loc[:,'D'] = np.array([5] * len(df))   //通过numpy赋值列
In [51]: df
Out[51]: 
                   A         B         C  D    F
2013-01-01  0.000000  0.000000 -1.509059  5  NaN
2013-01-02  1.212112 -0.173215  0.119209  5  1.0
2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0
2013-01-04  0.721555 -0.706771 -1.039575  5  3.0
2013-01-05 -0.424972  0.567020  0.276232  5  4.0
2013-01-06 -0.673690  0.113648 -1.478427  5  5.0
1
2
3
4
5
6
7
8
9
10
In [52]: df2 = df.copy()

In [53]: df2[df2 > 0] = -df2    //为每个数据赋值

In [54]: df2
Out[54]: 
                   A         B         C  D    F
2013-01-01  0.000000  0.000000 -1.509059 -5  NaN
2013-01-02 -1.212112 -0.173215 -0.119209 -5 -1.0
2013-01-03 -0.861849 -2.104569 -0.494929 -5 -2.0
2013-01-04 -0.721555 -0.706771 -1.039575 -5 -3.0
2013-01-05 -0.424972 -0.567020 -0.276232 -5 -4.0
2013-01-06 -0.673690 -0.113648 -1.478427 -5 -5.0
1
2
3
4
5
6
7
8
9
10
11
12
13
修改索引：

In [55]: df1 = df.reindex(index=dates[0:4], columns=list(df.columns) + ['E'])   //修改DataFrame的键

In [56]: df1.loc[dates[0]:dates[1],'E'] = 1

In [57]: df1
Out[57]: 
                   A         B         C  D    F    E
2013-01-01  0.000000  0.000000 -1.509059  5  NaN  1.0
2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0
2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0  NaN
2013-01-04  0.721555 -0.706771 -1.039575  5  3.0  NaN
1
2
3
4
5
6
7
8
9
10
11
六、缺失值处理
pandas用numpy.nan表示缺失值，不参与计算。 
去掉缺失行：

In [58]: df1.dropna(how='any')
Out[58]: 
                   A         B         C  D    F    E
2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0
1
2
3
4
填充缺失值：

In [59]: df1.fillna(value=5)   //对缺失值处进行填充
Out[59]: 
                   A         B         C  D    F    E
2013-01-01  0.000000  0.000000 -1.509059  5  5.0  1.0
2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0
2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0  5.0
2013-01-04  0.721555 -0.706771 -1.039575  5  3.0  5.0
1
2
3
4
5
6
7
判断何处缺失：

In [60]: pd.isnull(df1)    //判断位置元素是否为缺失值
Out[60]: 
                A      B      C      D      F      E
2013-01-01  False  False  False  False   True  False
2013-01-02  False  False  False  False  False  False
2013-01-03  False  False  False  False  False   True
2013-01-04  False  False  False  False  False   True
1
2
3
4
5
6
7
七、操作
偏移（对齐）元素：

In [63]: s = pd.Series([1,3,5,np.nan,6,8], index=dates).shift(2)                   //序列元素偏移两位

In [64]: s
Out[64]: 
2013-01-01    NaN
2013-01-02    NaN
2013-01-03    1.0
2013-01-04    3.0
2013-01-05    5.0
2013-01-06    NaN
Freq: D, dtype: float64

In [65]: df.sub(s, axis='index')
Out[65]: 
                   A         B         C    D    F
2013-01-01       NaN       NaN       NaN  NaN  NaN
2013-01-02       NaN       NaN       NaN  NaN  NaN
2013-01-03 -1.861849 -3.104569 -1.494929  4.0  1.0
2013-01-04 -2.278445 -3.706771 -4.039575  2.0  0.0
2013-01-05 -5.424972 -4.432980 -4.723768  0.0 -1.0
2013-01-06       NaN       NaN       NaN  NaN  NaN
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
对元素应用函数：

In [66]: df.apply(np.cumsum)    //对对象每个元素应用函数
Out[66]: 
                   A         B         C   D     F
2013-01-01  0.000000  0.000000 -1.509059   5   NaN
2013-01-02  1.212112 -0.173215 -1.389850  10   1.0
2013-01-03  0.350263 -2.277784 -1.884779  15   3.0
2013-01-04  1.071818 -2.984555 -2.924354  20   6.0
2013-01-05  0.646846 -2.417535 -2.648122  25  10.0
2013-01-06 -0.026844 -2.303886 -4.126549  30  15.0

In [67]: df.apply(lambda x: x.max() - x.min())
Out[67]: 
A    2.073961
B    2.671590
C    1.785291
D    0.000000
F    4.000000
dtype: float64
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
直方图：

In [68]: s = pd.Series(np.random.randint(0, 7, size=10))

In [69]: s
Out[69]: 
0    4
1    2
2    1
3    2
4    6
5    4
6    4
7    6
8    4
9    4
dtype: int64

In [70]: s.value_counts()   //统计值以数字格式显示直方图
Out[70]: 
4    5
6    2
2    2
1    1
dtype: int64
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
字符串操作：

In [71]: s = pd.Series(['A', 'B', 'C', 'Aaba', 'Baca', np.nan, 'CABA', 'dog', 'cat'])

In [72]: s.str.lower()   //序列字符串转成小写字母
Out[72]: 
0       a
1       b
2       c
3    aaba
4    baca
5     NaN
6    caba
7     dog
8     cat
dtype: object
1
2
3
4
5
6
7
8
9
10
11
12
13
14
八、合并
Comcat：

In [73]: df = pd.DataFrame(np.random.randn(10, 4))

In [74]: df
Out[74]: 
          0         1         2         3
0 -0.548702  1.467327 -1.015962 -0.483075
1  1.637550 -1.217659 -0.291519 -1.745505
2 -0.263952  0.991460 -0.919069  0.266046
3 -0.709661  1.669052  1.037882 -1.705775
4 -0.919854 -0.042379  1.247642 -0.009920
5  0.290213  0.495767  0.362949  1.548106
6 -1.131345 -0.089329  0.337863 -0.945867
7 -0.932132  1.956030  0.017587 -0.016692
8 -0.575247  0.254161 -1.143704  0.215897
9  1.193555 -0.077118 -0.408530 -0.862495

# break it into pieces
In [75]: pieces = [df[:3], df[3:7], df[7:]]

In [76]: pd.concat(pieces)
Out[76]: 
          0         1         2         3
0 -0.548702  1.467327 -1.015962 -0.483075
1  1.637550 -1.217659 -0.291519 -1.745505
2 -0.263952  0.991460 -0.919069  0.266046
3 -0.709661  1.669052  1.037882 -1.705775
4 -0.919854 -0.042379  1.247642 -0.009920
5  0.290213  0.495767  0.362949  1.548106
6 -1.131345 -0.089329  0.337863 -0.945867
7 -0.932132  1.956030  0.017587 -0.016692
8 -0.575247  0.254161 -1.143704  0.215897
9  1.193555 -0.077118 -0.408530 -0.862495
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
Join：


In [78]: right = pd.DataFrame({'key': ['foo', 'foo'], 'rval': [4, 5]})

In [79]: left
Out[79]: 
   key  lval
0  foo     1
1  foo     2

In [80]: right
Out[80]: 
   key  rval
0  foo     4
1  foo     5

In [81]: pd.merge(left, right, on='key')
Out[81]: 
   key  lval  rval
0  foo     1     4
1  foo     1     5
2  foo     2     4
3  foo     2     5
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
In [82]: left = pd.DataFrame({'key': ['foo', 'bar'], 'lval': [1, 2]})

In [83]: right = pd.DataFrame({'key': ['foo', 'bar'], 'rval': [4, 5]})

In [84]: left
Out[84]: 
   key  lval
0  foo     1
1  bar     2

In [85]: right
Out[85]: 
   key  rval
0  foo     4
1  bar     5

In [86]: pd.merge(left, right, on='key')
Out[86]: 
   key  lval  rval
0  foo     1     4
1  bar     2     5
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
Append：

In [87]: df = pd.DataFrame(np.random.randn(8, 4), columns=['A','B','C','D'])

In [88]: df
Out[88]: 
          A         B         C         D
0  1.346061  1.511763  1.627081 -0.990582
1 -0.441652  1.211526  0.268520  0.024580
2 -1.577585  0.396823 -0.105381 -0.532532
3  1.453749  1.208843 -0.080952 -0.264610
4 -0.727965 -0.589346  0.339969 -0.693205
5 -0.339355  0.593616  0.884345  1.591431
6  0.141809  0.220390  0.435589  0.192451
7 -0.096701  0.803351  1.715071 -0.708758

In [89]: s = df.iloc[3]

In [90]: df.append(s, ignore_index=True)
Out[90]: 
          A         B         C         D
0  1.346061  1.511763  1.627081 -0.990582
1 -0.441652  1.211526  0.268520  0.024580
2 -1.577585  0.396823 -0.105381 -0.532532
3  1.453749  1.208843 -0.080952 -0.264610
4 -0.727965 -0.589346  0.339969 -0.693205
5 -0.339355  0.593616  0.884345  1.591431
6  0.141809  0.220390  0.435589  0.192451
7 -0.096701  0.803351  1.715071 -0.708758
8  1.453749  1.208843 -0.080952 -0.264610
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
九、分组
In [91]: df = pd.DataFrame({'A' : ['foo', 'bar', 'foo', 'bar',
   ....:                           'foo', 'bar', 'foo', 'foo'],
   ....:                    'B' : ['one', 'one', 'two', 'three',
   ....:                           'two', 'two', 'one', 'three'],
   ....:                    'C' : np.random.randn(8),
   ....:                    'D' : np.random.randn(8)})
   ....: 

In [92]: df
Out[92]: 
     A      B         C         D
0  foo    one -1.202872 -0.055224
1  bar    one -1.814470  2.395985
2  foo    two  1.018601  1.552825
3  bar  three -0.595447  0.166599
4  foo    two  1.395433  0.047609
5  bar    two -0.392670 -0.136473
6  foo    one  0.007207 -0.561757
7  foo  three  1.928123 -1.623033

In [93]: df.groupby('A').sum()  //对键index A分组进行并对每个组执行sum函数
Out[93]: 
            C        D
A                     
bar -2.802588  2.42611
foo  3.146492 -0.63958
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
In [94]: df.groupby(['A','B']).sum()   //对index A B进行分组并对每个组执行sum函数
Out[94]: 
                  C         D
A   B                        
bar one   -1.814470  2.395985
    three -0.595447  0.166599
    two   -0.392670 -0.136473
foo one   -1.195665 -0.616981
    three  1.928123 -1.623033
    two    2.414034  1.600434
1
2
3
4
5
6
7
8
9
10
十、重切片
stack：压缩DataFrame列

In [99]: df2
Out[99]: 
                     A         B
first second                    
bar   one     0.029399 -0.542108
      two     0.282696 -0.087302
baz   one    -1.575170  1.771208
      two     0.816482  1.100230
In [100]: stacked = df2.stack()

In [101]: stacked  = df2.stack()
Out[101]: stacked
first  second   
bar    one     A    0.029399
               B   -0.542108
       two     A    0.282696
               B   -0.087302
baz    one     A   -1.575170
               B    1.771208
       two     A    0.816482
               B    1.100230
dtype: float64
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
unstack反解压到上一层，不同参数解压层不同

In [102]: stacked.unstack()
Out[102]: 
                     A         B
first second                    
bar   one     0.029399 -0.542108
      two     0.282696 -0.087302
baz   one    -1.575170  1.771208
      two     0.816482  1.100230

In [103]: stacked.unstack(1)
Out[103]: 
second        one       two
first                      
bar   A  0.029399  0.282696
      B -0.542108 -0.087302
baz   A -1.575170  0.816482
      B  1.771208  1.100230

In [104]: stacked.unstack(0)
Out[104]: 
first          bar       baz
second                      
one    A  0.029399 -1.575170
       B -0.542108  1.771208
two    A  0.282696  0.816482
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
透视Pivot表：

In [106]: df
Out[106]: 
        A  B    C         D         E
0     one  A  foo  1.418757 -0.179666
1     one  B  foo -1.879024  1.291836
2     two  C  foo  0.536826 -0.009614
3   three  A  bar  1.006160  0.392149
4     one  B  bar -0.029716  0.264599
5     one  C  bar -1.146178 -0.057409
6     two  A  foo  0.100900 -1.425638
7   three  B  foo -1.035018  1.024098
8     one  C  foo  0.314665 -0.106062
9     one  A  bar -0.773723  1.824375
10    two  B  bar -1.170653  0.595974
11  three  C  bar  0.648740  1.167115
In [107]: pd.pivot_table(df, values='D', index=['A', 'B'], columns=['C'])
Out[107]: 
C             bar       foo
A     B                    
one   A -0.773723  1.418757
      B -0.029716 -1.879024
      C -1.146178  0.314665
three A  1.006160       NaN
      B       NaN -1.035018
      C  0.648740       NaN
two   A       NaN  0.100900
      B -1.170653       NaN
      C       NaN  0.536826
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
十一、时间序列
生成：

In [108]: rng = pd.date_range('1/1/2012', periods=100, freq='S')

In [109]: ts = pd.Series(np.random.randint(0, 500, len(rng)), index=rng)

In [110]: ts.resample('5Min').sum()
Out[110]: 
2012-01-01    25083
Freq: 5T, dtype: int64
1
2
3
4
5
6
7
8
In [111]: rng = pd.date_range('3/6/2012 00:00', periods=5, freq='D')

In [112]: ts = pd.Series(np.random.randn(len(rng)), rng)

In [113]: ts
Out[113]: 
2012-03-06    0.464000
2012-03-07    0.227371
2012-03-08   -0.496922
2012-03-09    0.306389
2012-03-10   -2.290613
Freq: D, dtype: float64

In [114]: ts_utc = ts.tz_localize('UTC')

In [115]: ts_utc
Out[115]: 
2012-03-06 00:00:00+00:00    0.464000
2012-03-07 00:00:00+00:00    0.227371
2012-03-08 00:00:00+00:00   -0.496922
2012-03-09 00:00:00+00:00    0.306389
2012-03-10 00:00:00+00:00   -2.290613
Freq: D, dtype: float64
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
转换时间区：

In [116]: ts_utc.tz_convert('US/Eastern')
Out[116]: 
2012-03-05 19:00:00-05:00    0.464000
2012-03-06 19:00:00-05:00    0.227371
2012-03-07 19:00:00-05:00   -0.496922
2012-03-08 19:00:00-05:00    0.306389
2012-03-09 19:00:00-05:00   -2.290613
Freq: D, dtype: float64
1
2
3
4
5
6
7
8
显示格式转换：

In [117]: rng = pd.date_range('1/1/2012', periods=5, freq='M')

In [118]: ts = pd.Series(np.random.randn(len(rng)), index=rng)

In [119]: ts
Out[119]: 
2012-01-31   -1.134623
2012-02-29   -1.561819
2012-03-31   -0.260838
2012-04-30    0.281957
2012-05-31    1.523962
Freq: M, dtype: float64

In [120]: ps = ts.to_period()

In [121]: ps
Out[121]: 
2012-01   -1.134623
2012-02   -1.561819
2012-03   -0.260838
2012-04    0.281957
2012-05    1.523962
Freq: M, dtype: float64

In [122]: ps.to_timestamp()
Out[122]: 
2012-01-01   -1.134623
2012-02-01   -1.561819
2012-03-01   -0.260838
2012-04-01    0.281957
2012-05-01    1.523962
Freq: MS, dtype: float64
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
In [123]: prng = pd.period_range('1990Q1', '2000Q4', freq='Q-NOV')

In [124]: ts = pd.Series(np.random.randn(len(prng)), prng)

In [125]: ts.index = (prng.asfreq('M', 'e') + 1).asfreq('H', 's') + 9

In [126]: ts.head()
Out[126]: 
1990-03-01 09:00   -0.902937
1990-06-01 09:00    0.068159
1990-09-01 09:00   -0.057873
1990-12-01 09:00   -0.368204
1991-03-01 09:00   -1.144073
Freq: H, dtype: float64
1
2
3
4
5
6
7
8
9
10
11
12
13
14
十二、categoricals
version 0.15后DataFrame能够包含categorical

In [127]: df = pd.DataFrame({"id":[1,2,3,4,5,6], "raw_grade":['a', 'b', 'b', 'a', 'a', 'e']})
In [128]: df["grade"] = df["raw_grade"].astype("category")

In [129]: df["grade"]
Out[129]: 
0    a
1    b
2    b
3    a
4    a
5    e
Name: grade, dtype: category
Categories (3, object): [a, b, e]
1
2
3
4
5
6
7
8
9
10
11
12
13
重命名categorical：

df["grade"].cat.categories = ["very good", "good", "very bad"]
1
重排categorical并加入缺失categorical：

In [131]: df["grade"] = df["grade"].cat.set_categories(["very bad", "bad", "medium", "good", "very good"])

In [132]: df["grade"]
Out[132]: 
0    very good
1         good
2         good
3    very good
4    very good
5     very bad
Name: grade, dtype: category
Categories (5, object): [very bad, bad, medium, good, very good]
1
2
3
4
5
6
7
8
9
10
11
12
根据categorical排序：

In [133]: df.sort_values(by="grade")
Out[133]: 
   id raw_grade      grade
5   6         e   very bad
1   2         b       good
2   3         b       good
0   1         a  very good
3   4         a  very good
1
2
3
4
5
6
7
8
分组categorical：

In [134]: df.groupby("grade").size()
Out[134]: 
grade
very bad     1
bad          0
medium       0
good         2
very good    3
dtype: int64
1
2
3
4
5
6
7
8
9
十三、画图
官方文档 
一般不使用pandas的画图功能，而使用其他如matplotlib等。

十四、读取存储
CSV：

写入：
 df.to_csv('foo.csv')
读取：
 In [142]: pd.read_csv('foo.csv')
Out[142]: 
     Unnamed: 0          A          B         C          D
0    2000-01-01   0.266457  -0.399641 -0.219582   1.186860
1    2000-01-02  -1.170732  -0.345873  1.653061  -0.282953
2    2000-01-03  -1.734933   0.530468  2.060811  -0.515536
3    2000-01-04  -1.555121   1.452620  0.239859  -1.156896
4    2000-01-05   0.578117   0.511371  0.103552  -2.428202
5    2000-01-06   0.478344   0.449933 -0.741620  -1.962409
6    2000-01-07   1.235339  -0.091757 -1.543861  -1.084753
..          ...        ...        ...       ...        ...
993  2002-09-20 -10.628548  -9.153563 -7.883146  28.313940
994  2002-09-21 -10.390377  -8.727491 -6.399645  30.914107
995  2002-09-22  -8.985362  -8.485624 -4.669462  31.367740
996  2002-09-23  -9.558560  -8.781216 -4.499815  30.518439
997  2002-09-24  -9.902058  -9.340490 -4.386639  30.105593
998  2002-09-25 -10.216020  -9.480682 -3.933802  29.758560
999  2002-09-26 -11.856774 -10.671012 -3.216025  29.369368

[1000 rows x 5 columns]
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
HDF5：

df.to_hdf('foo.h5','df')
In [144]: pd.read_hdf('foo.h5','df')
Out[144]: 
                    A          B         C          D
2000-01-01   0.266457  -0.399641 -0.219582   1.186860
2000-01-02  -1.170732  -0.345873  1.653061  -0.282953
2000-01-03  -1.734933   0.530468  2.060811  -0.515536
2000-01-04  -1.555121   1.452620  0.239859  -1.156896
2000-01-05   0.578117   0.511371  0.103552  -2.428202
2000-01-06   0.478344   0.449933 -0.741620  -1.962409
2000-01-07   1.235339  -0.091757 -1.543861  -1.084753
...               ...        ...       ...        ...
2002-09-20 -10.628548  -9.153563 -7.883146  28.313940
2002-09-21 -10.390377  -8.727491 -6.399645  30.914107
2002-09-22  -8.985362  -8.485624 -4.669462  31.367740
2002-09-23  -9.558560  -8.781216 -4.499815  30.518439
2002-09-24  -9.902058  -9.340490 -4.386639  30.105593
2002-09-25 -10.216020  -9.480682 -3.933802  29.758560
2002-09-26 -11.856774 -10.671012 -3.216025  29.369368

[1000 rows x 4 columns]
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
EXCEL：

df.to_excel('foo.xlsx', sheet_name='Sheet1')
In [146]: pd.read_excel('foo.xlsx', 'Sheet1', index_col=None, na_values=['NA'])
Out[146]: 
                    A          B         C          D
2000-01-01   0.266457  -0.399641 -0.219582   1.186860
2000-01-02  -1.170732  -0.345873  1.653061  -0.282953
2000-01-03  -1.734933   0.530468  2.060811  -0.515536
2000-01-04  -1.555121   1.452620  0.239859  -1.156896
2000-01-05   0.578117   0.511371  0.103552  -2.428202
2000-01-06   0.478344   0.449933 -0.741620  -1.962409
2000-01-07   1.235339  -0.091757 -1.543861  -1.084753
...               ...        ...       ...        ...
2002-09-20 -10.628548  -9.153563 -7.883146  28.313940
2002-09-21 -10.390377  -8.727491 -6.399645  30.914107
2002-09-22  -8.985362  -8.485624 -4.669462  31.367740
2002-09-23  -9.558560  -8.781216 -4.499815  30.518439
2002-09-24  -9.902058  -9.340490 -4.386639  30.105593
2002-09-25 -10.216020  -9.480682 -3.933802  29.758560
2002-09-26 -11.856774 -10.671012 -3.216025  29.369368

[1000 rows x 4 columns]